import type { UmbValidationMessageTranslator } from '../translators/validation-message-translator.interface.js';
import type { UmbValidator } from '../interfaces/validator.interface.js';
import { UmbDataPathPropertyValueFilter } from '../utils/data-path-property-value-filter.function.js';
import { UMB_VALIDATION_CONTEXT } from './validation.context-token.js';
import { UMB_SERVER_MODEL_VALIDATION_CONTEXT } from './server-model-validation.context-token.js';
import { UmbContextBase } from '@umbraco-cms/backoffice/class-api';
import type { UmbControllerHost } from '@umbraco-cms/backoffice/controller-api';
import type { UmbDataSourceResponse } from '@umbraco-cms/backoffice/repository';

type ServerFeedbackEntry = { path: string; messages: Array<string> };

/** This should ideally be generated by the server, but we currently don't generate error-modal-types. */
interface ValidateErrorResponseBodyModel {
	detail: string;
	errors: Record<string, Array<string>>;
	missingProperties: Array<string>;
	operationStatus: string;
	status: number;
	title: string;
	type: string;
}

export class UmbServerModelValidationContext
	extends UmbContextBase<UmbServerModelValidationContext>
	implements UmbValidator
{
	#validatePromise?: Promise<void>;
	#validatePromiseResolve?: () => void;

	#context?: typeof UMB_VALIDATION_CONTEXT.TYPE;
	#isValid = true;

	#data: any;
	getData(): any {
		return this.#data;
	}
	#translators: Array<UmbValidationMessageTranslator> = [];

	constructor(host: UmbControllerHost) {
		super(host, UMB_SERVER_MODEL_VALIDATION_CONTEXT);
		this.consumeContext(UMB_VALIDATION_CONTEXT, (context) => {
			if (this.#context) {
				this.#context.removeValidator(this);
			}
			this.#context = context;
			context.addValidator(this);

			// Run translators?
		});
	}

	async askServerForValidation(data: unknown, requestPromise: Promise<UmbDataSourceResponse<string>>): Promise<void> {
		this.#context?.messages.removeMessagesByType('server');

		const serverFeedback: Array<ServerFeedbackEntry> = [];
		this.#isValid = false;
		//this.#validatePromiseReject?.();
		this.#validatePromise = new Promise<void>((resolve) => {
			this.#validatePromiseResolve = resolve;
		});

		// Store this state of the data for translator look ups:
		this.#data = data;
		// Ask the server for validation...
		const { error } = await requestPromise;

		this.#isValid = error ? false : true;

		if (!this.#isValid) {
			// We are missing some typing here, but we will just go wild with 'as any': [NL]
			const errorBody = (error as any).body as ValidateErrorResponseBodyModel;
			// Check if there are validation errors, since the error might be a generic ApiError
			if (errorBody?.errors) {
				Object.keys(errorBody.errors).forEach((path) => {
					serverFeedback.push({ path, messages: errorBody.errors[path] });
				});
			}
			// Check if there are missing properties:
			console.log('send data:', this.#data);
			console.log('error response:', errorBody);
			if (errorBody?.missingProperties) {
				// Retrieve the variants of he send data, as those are the once we will declare as missing properties:
				errorBody.missingProperties.forEach((alias) => {
					this.#data.variants.forEach((variant: any) => {
						serverFeedback.push({
							path: `$.values[${UmbDataPathPropertyValueFilter({
								alias: alias,
								culture: variant.culture,
								segment: variant.segment,
							})}].value`,
							messages: ['#validation_invalidEmpty'],
						});
					});
				});
			}
		}

		this.#validatePromiseResolve?.();
		this.#validatePromiseResolve = undefined;

		// Translate feedback:
		serverFeedback.forEach(this.#executeTranslatorsOnFeedback);
	}

	#executeTranslatorsOnFeedback = (feedback: ServerFeedbackEntry) => {
		if (!this.#context) {
			throw new Error('No context available for translation.');
		}
		const foundTranslator = this.#translators.find((translator) => {
			const newPath = translator.translate(feedback.path);
			if (newPath !== false) {
				// TODO: I might need to restructure this part for adjusting existing feedback with a part-translation.
				// Detect if some part is unhandled?
				// If so only make a partial translation on the feedback, add a message for the handled part.
				// then return [ of the partial translated feedback, and the partial handled part. ];

				//  TODO:Check if there was any temporary messages base on this path, like if it was partial-translated at one point..
				if (newPath !== undefined) {
					this.#context!.messages.addMessages('server', newPath, feedback.messages);
					return true;
				} else {
					// If the newPath is undefined, then there was a translation error and we should not keep the message.
					throw new Error(
						'Validation Translator returned undefined, which means it failed to translate the path. Translator: ' +
							translator.constructor.name +
							', Path: ' +
							feedback.path,
					);
				}
			}
			return false;
		});
		if (foundTranslator) {
			// Because this was successfully translated, we can remove the feedback from the server:
			return [];
		} else {
			// Because this was not translated, we will carry over the message as is:
			this.#context.messages.addMessages('server', feedback.path, feedback.messages);
			return [];
		}
	};

	addTranslator(translator: UmbValidationMessageTranslator): void {
		if (this.#translators.indexOf(translator) === -1) {
			this.#translators.push(translator);
		}
		// execute translators here?
	}

	removeTranslator(translator: UmbValidationMessageTranslator): void {
		const index = this.#translators.indexOf(translator);
		if (index !== -1) {
			this.#translators.splice(index, 1);
		}
	}

	get isValid(): boolean {
		return this.#isValid;
	}
	async validate(): Promise<void> {
		if (this.#validatePromise) {
			await this.#validatePromise;
		}
		return this.#isValid ? Promise.resolve() : Promise.reject();
	}

	reset(): void {}

	focusFirstInvalidElement(): void {}

	override hostConnected(): void {
		super.hostConnected();
		if (this.#context) {
			this.#context.addValidator(this);
		}
	}
	override hostDisconnected(): void {
		super.hostDisconnected();
		if (this.#context) {
			this.#context.removeValidator(this);
			this.#context = undefined;
		}
	}

	override destroy(): void {
		// TODO: make sure we destroy things properly:
		this.#translators = [];
		super.destroy();
	}
}
